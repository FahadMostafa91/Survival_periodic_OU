# -*- coding: utf-8 -*-
"""Survival_SDE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z70CnsY1v1P7h-jTJgV_2rrVJCFnpXI0
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.stats import norm
from scipy.special import erfc

# Parameters for simulation
T = 1000  # total time
dt = 0.01  # time step
N = int(T / dt)  # number of time steps
num_paths = 10000  # number of simulated paths
x0 = 0.0  # initial value
gamma_values = [1.5, 2.0, 2.5]  # thresholds
t_values = [2, 5, 10, 20]  # time points to evaluate survival probability

# Time grid
time = np.linspace(0, T, N)

# Define periodic coefficients
def beta(t):
    return 0.5 * np.sin(2 * np.pi * t / 100)

def r(t):
    return 1.0 + 0.3 * np.cos(2 * np.pi * t / 200)

def sigma(t):
    return 0.5 + 0.2 * np.sin(2 * np.pi * t / 150)

# Storage for survival probabilities
results = []

# Simulate for different gamma values
for gamma in gamma_values:
    survival_probs_empirical = []
    survival_probs_analytic = []

    for t_eval in t_values:
        t_idx = int(t_eval / dt)

        # Simulate paths
        X = np.full((num_paths,), x0)
        survived = np.ones(num_paths, dtype=bool)

        for i in range(t_idx):
            t_curr = i * dt
            dW = np.random.normal(0, np.sqrt(dt), size=num_paths)
            X[survived] += r(t_curr) * (beta(t_curr) - X[survived]) * dt + sigma(t_curr) * dW[survived]
            survived = survived & (X < gamma)

        emp_survival = np.mean(survived)

        # Analytical approximation using OU-like formula
        sig_eff = np.mean([sigma(i * dt)**2 for i in range(t_idx)])  # mean sigma^2
        r_eff = np.mean([r(i * dt) for i in range(t_idx)])
        t1 = 1 / (r_eff * gamma) * np.sqrt(2 * np.pi * sig_eff / r_eff) * np.exp((r_eff * gamma**2) / (2 * sig_eff))
        approx_survival = np.exp(-t_eval / t1)

        survival_probs_empirical.append(emp_survival)
        survival_probs_analytic.append(approx_survival)

        results.append({
            "gamma": gamma,
            "t": t_eval,
            "Empirical": emp_survival,
            "Analytical": approx_survival
        })

# Convert to DataFrame
df_results = pd.DataFrame(results)

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))
for gamma in gamma_values:
    sub_df = df_results[df_results["gamma"] == gamma]
    ax.plot(sub_df["t"], sub_df["Empirical"], 'o-', label=f"Empirical γ={gamma}")
    ax.plot(sub_df["t"], sub_df["Analytical"], '--', label=f"Analytical γ={gamma}")

ax.set_xlabel("Time")
ax.set_ylabel("S(t,x)")
ax.set_title("Empirical vs Analytical Survival Probabilities")
ax.legend()
ax.grid(True)
plt.show()


print(df_results)

import numpy as np
import matplotlib.pyplot as plt

# Define the same SDE model parameters
dt = 0.01
N = int(20 / dt)  # simulate up to t=20
num_paths = 5000
x_vals = np.linspace(0, 3.5, 100)

# Coefficients
def beta(t): return 0.5 * np.sin(2 * np.pi * t / 100)
def r(t): return 1.0 + 0.3 * np.cos(2 * np.pi * t / 200)
def sigma(t): return 0.5 + 0.2 * np.sin(2 * np.pi * t / 150)

# Time steps to plot
t_plot = [0.01, 1, 5, 10, 20]
gamma = 3.5

# Initialize plots
fig, axs = plt.subplots(2, 2, figsize=(14, 10))
axs = axs.ravel()

# Simulate paths and compute empirical survival probability across x
for idx, t_eval in enumerate(t_plot):
    t_idx = int(t_eval / dt)
    surv_probs = []

    for x0 in x_vals:
        X = np.full((num_paths,), x0)
        survived = np.ones(num_paths, dtype=bool)
        for i in range(t_idx):
            t_curr = i * dt
            dW = np.random.normal(0, np.sqrt(dt), size=num_paths)
            X[survived] += r(t_curr) * (beta(t_curr) - X[survived]) * dt + sigma(t_curr) * dW[survived]
            survived = survived & (X < gamma)
        surv_probs.append(np.mean(survived))

    axs[idx//2].plot(x_vals, surv_probs, label=f't = {t_eval:.2f}')

for ax in axs:
    ax.set_ylim(0, 1.05)
    ax.set_xlim(0, 3.5)
    ax.set_xlabel('$x$')
    ax.set_ylabel('$S(x, t)$')
    ax.grid(True)
    ax.legend()
    ax.set_title('Survival Probability vs $x$ at different $t$')

plt.tight_layout()
plt.show()

# Reduce simulation burden by limiting paths and resolution
dt = 0.01
N = int(20 / dt)
num_paths = 1000  # reduced from 5000
x_vals = np.linspace(0, 3.5, 50)  # reduced resolution

# Time steps to plot (keep a subset for speed)
t_plot = [0.01, 1, 5, 10]

# Initialize plots
fig, axs = plt.subplots(2, 2, figsize=(14, 10))
axs = axs.ravel()

# Simulate and plot
for idx, t_eval in enumerate(t_plot):
    t_idx = int(t_eval / dt)
    surv_probs = []

    for x0 in x_vals:
        X = np.full((num_paths,), x0)
        survived = np.ones(num_paths, dtype=bool)
        for i in range(t_idx):
            t_curr = i * dt
            dW = np.random.normal(0, np.sqrt(dt), size=num_paths)
            X[survived] += r(t_curr) * (beta(t_curr) - X[survived]) * dt + sigma(t_curr) * dW[survived]
            survived = survived & (X < gamma)
        surv_probs.append(np.mean(survived))

    axs[idx].plot(x_vals, surv_probs, 'o-', label=f't = {t_eval:.2f}')

    axs[idx].set_ylim(0, 1.05)
    axs[idx].set_xlim(0, 5.5)
    axs[idx].set_xlabel('$x$')
    axs[idx].set_ylabel('$S(x, t)$')
    axs[idx].grid(True)
    axs[idx].legend()
    axs[idx].set_title('Survival Probability vs $x$')

plt.tight_layout()
plt.show()

from scipy.special import erfc

# Analytical survival probability function (OU-like structure with rescaled coefficients)
def analytical_survival(x, t, gamma, r_eff, sigma_eff):
    t1 = 1 / (r_eff * gamma) * np.sqrt(2 * np.pi * sigma_eff / r_eff) * np.exp((r_eff * gamma**2) / (2 * sigma_eff))
    return np.exp(-t / t1) * (1 - np.exp(gamma * (x - gamma)))

# Effective values (time-averaged over [0, t])
def compute_effective_coeffs(t_eval):
    steps = int(t_eval / dt)
    r_vals = np.array([r(i * dt) for i in range(steps)])
    sigma_vals = np.array([sigma(i * dt) for i in range(steps)])
    r_eff = np.mean(r_vals)
    sigma_eff = np.mean(sigma_vals**2)
    return r_eff, sigma_eff

# Plotting empirical and analytical together
fig, axs = plt.subplots(2, 2, figsize=(14, 10))
axs = axs.ravel()

for idx, t_eval in enumerate(t_plot):
    t_idx = int(t_eval / dt)
    surv_probs = []
    r_eff, sigma_eff = compute_effective_coeffs(t_eval)

    for x0 in x_vals:
        X = np.full((num_paths,), x0)
        survived = np.ones(num_paths, dtype=bool)
        for i in range(t_idx):
            t_curr = i * dt
            dW = np.random.normal(0, np.sqrt(dt), size=num_paths)
            X[survived] += r(t_curr) * (beta(t_curr) - X[survived]) * dt + sigma(t_curr) * dW[survived]
            survived = survived & (X < gamma)
        surv_probs.append(np.mean(survived))

    # Analytical approximation
    S_analytic = analytical_survival(x_vals, t_eval, gamma, r_eff, sigma_eff)

    axs[idx].plot(x_vals, surv_probs, 'o-', label=f'Empirical t = {t_eval:.2f}')
    axs[idx].plot(x_vals, S_analytic, '--', label=f'Analytical t = {t_eval:.2f}')

    axs[idx].set_ylim(0, 1.05)
    axs[idx].set_xlim(0, 2.65)
    axs[idx].set_xlabel('$x$')
    axs[idx].set_ylabel('$S(x, t)$')
    axs[idx].grid(True)
    axs[idx].legend()
    axs[idx].set_title('Empirical vs Analytical $S(x, t)$')

plt.tight_layout()
plt.show()

# Re-run the simulation since the code environment was reset

import numpy as np
import matplotlib.pyplot as plt

# Parameters derived from COVID-19 data (mortality = 39%, so survival ≈ 61%)
t_range = np.arange(0, 100, 1)
gamma = 1.0  # symbolic threshold
beta_0 = 0.61  # mean survival estimate from Kaplan-Meier curve
A = 0.1  # small seasonal variation
T_period = 60  # days
r = 0.05  # recovery rate (assumed)
sigma = 0.1  # volatility

# Periodic coefficient functions
def beta(t):
    return beta_0 + A * np.sin(2 * np.pi * t / T_period)

def r_t(t):
    return r * (1 + 0.1 * np.cos(2 * np.pi * t / T_period))

def sigma_t(t):
    return sigma * (1 + 0.2 * np.sin(2 * np.pi * t / T_period))

# Simulation settings
dt = 1.0
n_sim = 5000
X_init = 0.0
S_prob = []

# Monte Carlo simulation of survival probability
for t_eval in t_range:
    X = np.full(n_sim, X_init)
    survived = np.ones(n_sim, dtype=bool)
    for t in range(t_eval):
        dW = np.random.normal(0, np.sqrt(dt), size=n_sim)
        X[survived] += r_t(t) * (beta(t) - X[survived]) * dt + sigma_t(t) * dW[survived]
        survived = survived & (X < gamma)
    S_prob.append(np.mean(survived))

# Plotting results
plt.figure(figsize=(10, 6))
plt.plot(t_range, S_prob, label='Survival Probability', color='blue')
#plt.axhline(y=0.61, color='red', linestyle='--')
plt.xlabel('Hospital Days')
plt.ylabel('Survival Probability')
plt.title('Survival Probability using Periodic Mean-Reverting OU Process\n(COVID-19 ICU Patients)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# lifelines not available, use numpy and matplotlib to construct a basic Kaplan-Meier style estimate manually

# Redefine simulation to record event/censoring times
n_sim = 5000
max_days = 100
event_times = []
events_observed = []

for _ in range(n_sim):
    X = X_init
    for t in range(max_days):
        dW = np.random.normal(0, np.sqrt(dt))
        X += r_t(t) * (beta(t) - X) * dt + sigma_t(t) * dW
        if X >= gamma:
            event_times.append(t)
            events_observed.append(1)
            break
    else:
        event_times.append(max_days)
        events_observed.append(0)  # censored

# Sort event times
sorted_times = np.argsort(event_times)
event_times_sorted = np.array(event_times)[sorted_times]
events_observed_sorted = np.array(events_observed)[sorted_times]

# Manual Kaplan-Meier estimation
times = np.arange(0, max_days + 1)
n_risk = n_sim
survival_prob = [1.0]
curr_surv = 1.0
j = 0

for t in times[1:]:
    n_events = np.sum((event_times_sorted == t) & (events_observed_sorted == 1))
    n_censored = np.sum((event_times_sorted == t) & (events_observed_sorted == 0))
    if n_risk > 0:
        curr_surv *= (1 - n_events / n_risk)
    survival_prob.append(curr_surv)
    n_risk -= (n_events + n_censored)

# Plot Kaplan-Meier curve
plt.figure(figsize=(10, 6))
plt.step(times, survival_prob, where='post', label='Kaplan-Meier Estimate (Simulated)', color='blue')
plt.axhline(y=0.61, color='red', linestyle='--', label='Empirical COVID-19 Survival (1 - 0.39)')
plt.title("Kaplan-Meier Survival Curve (Simulated COVID-19 ICU Data)")
plt.xlabel("Time (Hospital Days)")
plt.ylabel("Survival Probability")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

!pip install lifelines

# Re-import necessary modules due to code execution state reset
import numpy as np
import matplotlib.pyplot as plt
from lifelines import KaplanMeierFitter

# Re-define parameters and functions
dt = 1.0
n_sim = 5000
max_days = 100
gamma = 1.0
X_init = 0.0

beta_0 = 0.61
A = 0.1
T_period = 60
r = 0.05
sigma = 0.1

def beta(t):
    return beta_0 + A * np.sin(2 * np.pi * t / T_period)

def r_t(t):
    return r * (1 + 0.1 * np.cos(2 * np.pi * t / T_period))

def sigma_t(t):
    return sigma * (1 + 0.2 * np.sin(2 * np.pi * t / T_period))

# Generate time-to-event and censoring indicators
time_to_event = np.zeros(n_sim)
event_observed = np.zeros(n_sim)

for i in range(n_sim):
    X = X_init
    for t in range(max_days):
        dW = np.random.normal(0, np.sqrt(dt))
        X += r_t(t) * (beta(t) - X) * dt + sigma_t(t) * dW
        if X >= gamma:
            time_to_event[i] = t
            event_observed[i] = 1
            break
    else:
        time_to_event[i] = max_days
        event_observed[i] = 0

# Kaplan-Meier estimation
kmf = KaplanMeierFitter()
kmf.fit(time_to_event, event_observed)

# Plot Kaplan-Meier survival curve
plt.figure(figsize=(10, 6))
kmf.plot(ci_show=True)
plt.title('Kaplan-Meier Survival Curve\n(Periodic OU Model for COVID-19 ICU Patients)')
plt.xlabel('Hospital Days')
plt.ylabel('Survival Probability')
plt.grid(True)
plt.tight_layout()
plt.show()

# Plot Kaplan-Meier survival curve
plt.figure(figsize=(10, 6))
kmf.plot(ci_show=True)
#plt.title('Kaplan-Meier Survival Curve\n(Periodic OU Model for COVID-19 ICU Patients)')
plt.xlabel('Hospital Days t')
plt.ylabel('Survival Probability S(x,t)')
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Parameter learning**"""

# Gaussian Process regression for learning time-varying r(t), sigma(t), and beta(t)
# We simulate synthetic noisy observations of r(t), sigma(t), and beta(t)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, WhiteKernel

# Time domain
T = 100
time = np.linspace(0, T, 200)

# True underlying functions (unknown in real-world but used here for simulation)
def true_beta(t): return 0.6 + 0.1 * np.sin(2 * np.pi * t / 60)
def true_r(t): return 0.05 * (1 + 0.1 * np.cos(2 * np.pi * t / 60))
def true_sigma(t): return 0.1 * (1 + 0.2 * np.sin(2 * np.pi * t / 60))

# Generate noisy observations at random time points
np.random.seed(42)
sample_idx = np.sort(np.random.choice(len(time), size=40, replace=False))
t_samples = time[sample_idx]

beta_obs = true_beta(t_samples) + np.random.normal(0, 0.01, size=t_samples.shape)
r_obs = true_r(t_samples) + np.random.normal(0, 0.002, size=t_samples.shape)
sigma_obs = true_sigma(t_samples) + np.random.normal(0, 0.003, size=t_samples.shape)

# Define kernel: smooth RBF + noise
kernel = RBF(length_scale=20.0) + WhiteKernel(noise_level=1e-4)

# Fit GP models
gp_beta = GaussianProcessRegressor(kernel=kernel).fit(t_samples.reshape(-1, 1), beta_obs)
gp_r = GaussianProcessRegressor(kernel=kernel).fit(t_samples.reshape(-1, 1), r_obs)
gp_sigma = GaussianProcessRegressor(kernel=kernel).fit(t_samples.reshape(-1, 1), sigma_obs)

# Predict on the full time grid
beta_pred, beta_std = gp_beta.predict(time.reshape(-1, 1), return_std=True)
r_pred, r_std = gp_r.predict(time.reshape(-1, 1), return_std=True)
sigma_pred, sigma_std = gp_sigma.predict(time.reshape(-1, 1), return_std=True)

# Plotting
fig, axs = plt.subplots(3, 1, figsize=(12, 10), sharex=True)

# Beta
axs[0].plot(time, true_beta(time), 'k--', label='True β(t)')
axs[0].scatter(t_samples, beta_obs, color='blue', label='Observations')
axs[0].plot(time, beta_pred, 'r', label='GP Prediction')
axs[0].fill_between(time, beta_pred - 2 * beta_std, beta_pred + 2 * beta_std, color='r', alpha=0.2)
axs[0].set_ylabel('β(t)')
axs[0].legend()

# r
axs[1].plot(time, true_r(time), 'k--', label='True r(t)')
axs[1].scatter(t_samples, r_obs, color='blue', label='Observations')
axs[1].plot(time, r_pred, 'g', label='GP Prediction')
axs[1].fill_between(time, r_pred - 2 * r_std, r_pred + 2 * r_std, color='g', alpha=0.2)
axs[1].set_ylabel('r(t)')
axs[1].legend()

# Sigma
axs[2].plot(time, true_sigma(time), 'k--', label='True σ(t)')
axs[2].scatter(t_samples, sigma_obs, color='blue', label='Observations')
axs[2].plot(time, sigma_pred, 'purple', label='GP Prediction')
axs[2].fill_between(time, sigma_pred - 2 * sigma_std, sigma_pred + 2 * sigma_std, color='purple', alpha=0.2)
axs[2].set_xlabel('Time')
axs[2].set_ylabel('σ(t)')
axs[2].legend()

plt.tight_layout()
plt.show()

# Gaussian Process regression for r(t), sigma(t), and beta(t) for ICU COVID-19 patients using empirical hospital day data
# We'll simulate proxy observations from realistic hospital-related data based on literature

import numpy as np
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, WhiteKernel

# Simulate empirical day-wise observations over 100 days
np.random.seed(42)
days = np.linspace(0, 100, 100)

# Simulated noisy measurements for ICU patient trajectory proxies
# Assume smooth dynamics similar to those seen in ICU progression for COVID-19

# Mean severity (beta): assumed to fluctuate and mildly improve
beta_true = 0.65 - 0.1 * np.exp(-0.05 * days) * np.cos(2 * np.pi * days / 50)
beta_obs = beta_true + np.random.normal(0, 0.01, size=days.shape)

# Mean-reversion rate (r): assumed to decay slightly over time
r_true = 0.06 - 0.01 * np.exp(-0.03 * days)
r_obs = r_true + np.random.normal(0, 0.002, size=days.shape)

# Volatility (sigma): increases mid-period then declines
sigma_true = 0.08 + 0.03 * np.exp(-((days - 50) ** 2) / (2 * 15 ** 2))
sigma_obs = sigma_true + np.random.normal(0, 0.003, size=days.shape)

# Use Gaussian Process Regression
kernel = RBF(length_scale=15.0) + WhiteKernel(noise_level=1e-4)

# Fit GP models
gp_beta = GaussianProcessRegressor(kernel=kernel).fit(days.reshape(-1, 1), beta_obs)
gp_r = GaussianProcessRegressor(kernel=kernel).fit(days.reshape(-1, 1), r_obs)
gp_sigma = GaussianProcessRegressor(kernel=kernel).fit(days.reshape(-1, 1), sigma_obs)

# Predict with uncertainty
beta_pred, beta_std = gp_beta.predict(days.reshape(-1, 1), return_std=True)
r_pred, r_std = gp_r.predict(days.reshape(-1, 1), return_std=True)
sigma_pred, sigma_std = gp_sigma.predict(days.reshape(-1, 1), return_std=True)

# Plotting
fig, axs = plt.subplots(3, 1, figsize=(12, 10), sharex=True)

# β(t)
axs[0].plot(days, beta_true, 'k--', label='True β(t)')
axs[0].scatter(days, beta_obs, s=10, color='blue', label='Observations')
axs[0].plot(days, beta_pred, 'r', label='GP Prediction')
axs[0].fill_between(days, beta_pred - 2 * beta_std, beta_pred + 2 * beta_std, color='r', alpha=0.2)
axs[0].set_ylabel('β(t)')
axs[0].legend()

# r(t)
axs[1].plot(days, r_true, 'k--', label='True r(t)')
axs[1].scatter(days, r_obs, s=10, color='blue', label='Observations')
axs[1].plot(days, r_pred, 'g', label='GP Prediction')
axs[1].fill_between(days, r_pred - 2 * r_std, r_pred + 2 * r_std, color='g', alpha=0.2)
axs[1].set_ylabel('r(t)')
axs[1].legend()

# σ(t)
axs[2].plot(days, sigma_true, 'k--', label='True σ(t)')
axs[2].scatter(days, sigma_obs, s=10, color='blue', label='Observations')
axs[2].plot(days, sigma_pred, 'purple', label='GP Prediction')
axs[2].fill_between(days, sigma_pred - 2 * sigma_std, sigma_pred + 2 * sigma_std, color='purple', alpha=0.2)
axs[2].set_xlabel('Hospital Day')
axs[2].set_ylabel('σ(t)')
axs[2].legend()

plt.tight_layout()
plt.show()